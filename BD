--NU-FWQ
--[[
Integrated ESP + Silent Aimbot LocalScript with Rayfield UI
Features: Role Detection, Distance Locking, Enhanced Hint Matching, 
CUSTOMIZABLE NAMETAGS, and Silent Aimbot with Full Configuration

UPDATED: Added comprehensive silent aimbot with toggleable features
]]

-- Load Rayfield
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

-- Create the window
local Window = Rayfield:CreateWindow({
    Name = "Blood Debt ESP & Silent Aim",
    Icon = 0,
    LoadingTitle = "ESP & Silent Aim",
    LoadingSubtitle = "Integrated Script",
    Theme = "Default",
    DisableRayfieldPrompts = false,
    DisableBuildWarnings = false,
    ConfigurationSaving = {
        Enabled = true,
        FolderName = nil,
        FileName = "BloodDebt_Integrated"
    }
})

-- Create tabs
local ESPTab = Window:CreateTab("ESP", "rewind")
local AimbotTab = Window:CreateTab("Silent Aim", "crosshair")
local ConfigTab = Window:CreateTab("Configuration", "settings")

-- ============================================================================
-- SILENT AIMBOT CONFIGURATION
-- ============================================================================

local AimbotConfig = {
    HitChance = 100,
    WallCheck = false,
    TargetParts = {"Head", "Torso"},
    FOVRadius = 200,
    MaxIndicators = 2,
    IndicatorLifetime = 0.05,
    IndicatorSize = 0.5,
    CircleThickness = 2,
    CircleSides = 60,
    HighlightTarget = true,
    HighlightColor = Color3.new(1, 0, 0),
    HighlightTransparency = 0.5,
    Enabled = false,
    ShowFOVCircle = true,
    UseRandomPart = true
}

-- ============================================================================
-- AIMBOT VARIABLES AND FUNCTIONS
-- ============================================================================

local aimbotActive = false
local aimbotThread = nil
local hitIndicators = {}
local currentHighlight = nil
local aimbotConnections = {}
local originalFire = nil
local FastCast = nil
local Camera = nil
local LocalPlayer = nil
local Players = nil
local RunService = nil
local Workspace = nil
local ReplicatedStorage = nil

-- Apply global config if exists
if getgenv().HitChance then AimbotConfig.HitChance = getgenv().HitChance end
if getgenv().wallcheck ~= nil then AimbotConfig.WallCheck = getgenv().wallcheck end
if getgenv().TargetParts then AimbotConfig.TargetParts = getgenv().TargetParts end
if getgenv().radius then AimbotConfig.FOVRadius = getgenv().radius end
if getgenv().HighlightTarget ~= nil then AimbotConfig.HighlightTarget = getgenv().HighlightTarget end

-- Executor compatibility check
local function checkExecutorCompatibility()
    local success, executorName, version = pcall(identifyexecutor)
    if not success then return true end
    
    executorName = (executorName and executorName:upper()) or ""
    local blocked = {"XENO", "SOLARA"}
    
    for _, name in ipairs(blocked) do
        if executorName:find(name) then
            game.Players.LocalPlayer:Kick("Unsupported executor. Please use an alternative.")
            return false
        end
    end
    return true
end

-- Get executor global
local function getExecutorGlobal(...)
    for _, name in ipairs({...}) do
        local value = rawget(_G, name)
        if value then return value end
    end
    return nil
end

-- Check FFlag
local function checkFFlag(name, expectedValue)
    local success, result = pcall(getfflag, name)
    if not success then return false end
    
    if type(expectedValue) == "boolean" then
        return result == expectedValue
    end
    return tostring(result) == tostring(expectedValue)
end

-- Bin cleanup system
local Bin = {}
Bin.__index = Bin

function Bin.new()
    return setmetatable({head = nil, tail = nil}, Bin)
end

function Bin:add(item)
    local node = {item = item, next = nil}
    if not self.head then self.head = node end
    if self.tail then self.tail.next = node end
    self.tail = node
    return item
end

function Bin:batch(...)
    for _, item in ipairs({...}) do self:add(item) end
end

function Bin:destroy()
    while self.head do
        local item = self.head.item
        if type(item) == "function" then
            item()
        elseif typeof(item) == "RBXScriptConnection" then
            item:Disconnect()
        elseif type(item) == "thread" then
            task.cancel(item)
        elseif type(item) == "table" and (item.destroy or item.Destroy) then
            (item.destroy or item.Destroy)(item)
        end
        self.head = self.head.next
    end
    self.tail = nil
end

-- Base Component
local BaseComponent = {}
BaseComponent.__index = BaseComponent

function BaseComponent.new(instance)
    local self = setmetatable({}, BaseComponent)
    self.instance = instance
    self.bin = Bin.new()
    return self
end

function BaseComponent:destroy()
    self.bin:destroy()
end

-- Rig Component
local RigComponent = setmetatable({}, {__index = BaseComponent})
RigComponent.__index = RigComponent

function RigComponent.new(instance)
    local self = setmetatable(BaseComponent.new(instance), RigComponent)
    
    self.root = instance:WaitForChild("HumanoidRootPart", 5)
    self.head = instance:WaitForChild("Head", 5)
    self.humanoid = instance:WaitForChild("Humanoid", 5)
    
    if not (self.root and self.head and self.humanoid) then
        error("Failed to initialize rig components")
    end
    
    self.bin:batch(
        self.humanoid.Died:Connect(function() self:destroy() end),
        instance.Destroying:Connect(function() self:destroy() end)
    )
    
    return self
end

-- Character Component
local CharacterComponent = setmetatable({}, {__index = RigComponent})
CharacterComponent.__index = CharacterComponent
CharacterComponent.active = {}

function CharacterComponent.new(instance)
    return setmetatable(RigComponent.new(instance), CharacterComponent)
end

-- Player Component
local PlayerComponent = setmetatable({}, {__index = BaseComponent})
PlayerComponent.__index = PlayerComponent
PlayerComponent.active = {}

function PlayerComponent.new(instance)
    local self = setmetatable(BaseComponent.new(instance), PlayerComponent)
    self.name = instance.Name
    self.character = nil
    
    if instance.Character then
        task.spawn(function() self:onCharacterAdded(instance.Character) end)
    end
    
    self.bin:batch(
        instance.CharacterAdded:Connect(function(char) self:onCharacterAdded(char) end),
        instance.CharacterRemoving:Connect(function() self:onCharacterRemoving() end)
    )
    
    self.bin:add(function()
        PlayerComponent.active[instance] = nil
    end)
    
    PlayerComponent.active[instance] = self
    return self
end

function PlayerComponent:onCharacterAdded(character)
    if self.character then self.character:destroy() end
    self.character = CharacterComponent.new(character)
end

function PlayerComponent:onCharacterRemoving()
    if self.character then self.character:destroy() end
    self.character = nil
end

-- Component Controller
local ComponentController = {}
local rayParams

local function getRandomPart(character)
    local parts = {}
    for _, partName in ipairs(AimbotConfig.TargetParts) do
        local part = character.instance:FindFirstChild(partName)
        if part then table.insert(parts, part) end
    end
    
    if #parts == 0 then return nil end
    return parts[Random.new():NextInteger(1, #parts)]
end

function ComponentController.getTarget()
    local viewportSize = Camera.ViewportSize
    local screenCenter = Vector2.new(viewportSize.X / 2, viewportSize.Y / 2)
    local bestTarget, bestPart, bestWeight = nil, nil, -math.huge
    
    for _, component in pairs(PlayerComponent.active) do
        local character = component.character
        if not character then continue end
        
        local targetPart = AimbotConfig.UseRandomPart and getRandomPart(character) or character.instance:FindFirstChild(AimbotConfig.TargetParts[1])
        if not targetPart then continue end
        
        local position = character.root.Position
        local viewportPoint = Camera:WorldToViewportPoint(position)
        if viewportPoint.Z < 0 then continue end
        
        if AimbotConfig.WallCheck then
            local origin = Camera.CFrame.Position
            rayParams.FilterDescendantsInstances = {character.instance, LocalPlayer.Character}
            if Workspace:Raycast(origin, position - origin, rayParams) then
                continue
            end
        end
        
        local screenDistance = (Vector2.new(viewportPoint.X, viewportPoint.Y) - screenCenter).Magnitude
        if screenDistance > AimbotConfig.FOVRadius then continue end
        
        local weight = 1000 - screenDistance
        if weight > bestWeight then
            bestTarget = character
            bestPart = targetPart
            bestWeight = weight
        end
    end
    
    return bestTarget, bestPart
end

function ComponentController.init()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            task.spawn(function() PlayerComponent.new(player) end)
        end
    end
    
    Players.PlayerAdded:Connect(function(player)
        PlayerComponent.new(player)
    end)
    
    Players.PlayerRemoving:Connect(function(player)
        local component = PlayerComponent.active[player]
        if component then component:destroy() end
    end)
    
    rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Exclude
    rayParams.IgnoreWater = true
end

-- Range Controller with Hit Indicators
local RangeController = {}

local function calculateChance(percentage)
    percentage = math.floor(percentage)
    local chance = Random.new():NextNumber(0, 100)
    return chance <= percentage
end

local function showHitIndicator(position)
    local part = Instance.new("Part")
    part.Anchored = true
    part.CanCollide = false
    part.Size = Vector3.new(0.5, 0.5, 0.5)
    part.Shape = Enum.PartType.Ball
    part.Color = Color3.new(1, 0, 0)
    part.Material = Enum.Material.Neon
    part.Transparency = 0
    part.Position = position
    part.Parent = Workspace
    
    if #hitIndicators >= AimbotConfig.MaxIndicators then
        local oldest = table.remove(hitIndicators, 1)
        if oldest and oldest.Parent then oldest:Destroy() end
    end
    table.insert(hitIndicators, part)
    
    task.spawn(function()
        task.wait(AimbotConfig.IndicatorLifetime)
        if part and part.Parent then part:Destroy() end
        for i, indicator in ipairs(hitIndicators) do
            if indicator == part then
                table.remove(hitIndicators, i)
                break
            end
        end
    end)
end

local function updateTargetHighlight(character)
    if not AimbotConfig.HighlightTarget then
        if currentHighlight then
            currentHighlight:Destroy()
            currentHighlight = nil
        end
        return
    end
    
    if character then
        if not currentHighlight or currentHighlight.Adornee ~= character.instance then
            if currentHighlight then
                currentHighlight:Destroy()
            end
            
            currentHighlight = Instance.new("Highlight")
            currentHighlight.Adornee = character.instance
            currentHighlight.FillColor = AimbotConfig.HighlightColor
            currentHighlight.OutlineColor = Color3.new(1, 1, 1)
            currentHighlight.FillTransparency = AimbotConfig.HighlightTransparency
            currentHighlight.OutlineTransparency = 0
            currentHighlight.Parent = character.instance
        end
    else
        if currentHighlight then
            currentHighlight:Destroy()
            currentHighlight = nil
        end
    end
end

function RangeController.init()
    if not FastCast or originalFire then return end
    
    originalFire = FastCast.Fire
    
    FastCast.Fire = function(...)
        if not aimbotActive or not AimbotConfig.Enabled then
            return originalFire(...)
        end
        
        local args = {...}
        local bestCharacter, bestPart = ComponentController.getTarget()
        
        updateTargetHighlight(bestCharacter)
        
        if bestCharacter and bestPart and calculateChance(AimbotConfig.HitChance) then
            local targetPos = bestPart.Position
            local origin = args[2]
            local newDirection = (targetPos - origin).Unit * 1000
            args[3] = newDirection
            
            showHitIndicator(targetPos)
        end
        
        return originalFire(unpack(args))
    end
end

-- Visuals Controller
local VisualsController = {}
local fovCircle = nil

function VisualsController.init()
    if fovCircle then return end
    
    fovCircle = Drawing.new("Circle")
    fovCircle.Filled = false
    fovCircle.NumSides = AimbotConfig.CircleSides
    fovCircle.Thickness = AimbotConfig.CircleThickness
    fovCircle.Visible = false
    fovCircle.Color = Color3.new(1, 1, 1)
    fovCircle.Transparency = 1
    
    RunService.RenderStepped:Connect(function()
        if fovCircle and AimbotConfig.ShowFOVCircle and AimbotConfig.Enabled then
            local viewportSize = Camera.ViewportSize
            local screenCenter = Vector2.new(viewportSize.X / 2, viewportSize.Y / 2)
            fovCircle.Radius = AimbotConfig.FOVRadius
            fovCircle.Position = screenCenter
            fovCircle.Visible = true
        elseif fovCircle then
            fovCircle.Visible = false
        end
    end)
end

-- Camera Controller
local CameraController = {}

function CameraController.init()
    Camera = Workspace.CurrentCamera
    Workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
        Camera = Workspace.CurrentCamera or Camera
    end)
end

-- Initialize aimbot systems
local function initializeAimbot()
    if aimbotActive then return end
    
    -- Services
    Players = game:GetService("Players")
    RunService = game:GetService("RunService")
    ReplicatedStorage = game:GetService("ReplicatedStorage")
    Workspace = game:GetService("Workspace")
    LocalPlayer = Players.LocalPlayer
    
    -- Game-specific modules
    local Gun_utls = ReplicatedStorage:WaitForChild("gun_res", 30)
    local gun_lib = Gun_utls:WaitForChild("lib", 30)
    local projectileHandlerMod = gun_lib:WaitForChild("projectileHandler", 30)
    FastCast = require(projectileHandlerMod:WaitForChild("FastCastRedux", 30))
    Camera = Workspace.CurrentCamera
    
    ComponentController.init()
    RangeController.init()
    VisualsController.init()
    CameraController.init()
    
    aimbotActive = true
    print("Silent Aimbot initialized successfully")
end

-- Shutdown aimbot
local function shutdownAimbot()
    if not aimbotActive then return end
    
    -- Restore original Fire function
    if FastCast and originalFire then
        FastCast.Fire = originalFire
    end
    
    -- Clear highlights
    if currentHighlight then
        currentHighlight:Destroy()
        currentHighlight = nil
    end
    
    -- Clear hit indicators
    for _, indicator in ipairs(hitIndicators) do
        if indicator and indicator.Parent then
            indicator:Destroy()
        end
    end
    hitIndicators = {}
    
    -- Clear FOV circle
    if fovCircle then
        fovCircle:Remove()
        fovCircle = nil
    end
    
    -- Clear component data
    for _, component in pairs(PlayerComponent.active) do
        component:destroy()
    end
    PlayerComponent.active = {}
    
    aimbotActive = false
    print("Silent Aimbot shutdown complete")
end

-- ============================================================================
-- ESP VARIABLES (from original script)
-- ============================================================================

local espEnabled = false
local stopEspLoop = false
local espPlayerAddedConnection = nil
local espCharacterAddedConnections = {}
local rolesLockedByDistance = false
local lockedDistanceRoles = {}
local playersMatchingHints = {}
local hintTextConnection = nil
local firstVigilanteTracker = {}
local playersWithStandardKillerWeapons = {}
local droppedGunConnections = {}

-- Weapon lists (same as original)
local killerWeapons = {
    ["CharcoalSteel JS-22"] = true,
    ["Pretty Pink RR-LCP"] = true,
    ["JS2-BondsDerringy"] = true,
    ["GILDED"] = true,
    ["Kamatov"] = true,
    ["JS2-Derringy"] = true,
    ["JS-22"] = true,
    ["RR-LightCompactPistolS"] = true,
    ["J9-Mereta"] = true,
    ["RY's GG-17"] = true,
    ["RR-LCP"] = true,
    ["JS1-Competitor"] = true,
    ["AT's KAR15"] = true,
    ["VK's ANKM"] = true,
    ["Clothed Sawn-off"] = true,
    ["Sawn-off"] = true,
    ["Clothed Rosen-Obrez"] = true,
    ["Rosen-Obrez"] = true,
    ["GraySteel K1911"] = true,
    ["DarkSteel K1911"] = true,
    ["SilverSteel K1911"] = true,
    ["K1911"] = true,
    ["ZZ-90"] = true,
    ["SKORPION"] = true,
    ["Mares Leg"] = true,
    ["RR-LightCompactPistol"] = true,
    ["KamatovS"] = true,
    ["ChromeSlide Turqoise RR-LCP"] = true,
    ["JS1-CYCLOPS"] = true,
    ["THUMPA"] = true,
    ["LUT-E 'KRUS'"] = true,
    ["Memories"] = true,
    ["Hammer n Bullet"] = true,
    ["JS-22GILDED"] = true,
    ["Sawn-offGILDED"] = true,
    ["Door'bler TIGERSTRIPES"] = true,
    ["Anatoly's JS-22"] = true,
    ["PLASTIC JS-22"] = true,
    ["JTS225-OBREZ"] = true,
    ["HEARDBALLA"] = true,
    ["Whiteout Rosen-Obrez"] = true,
    ["Whiteout RR-LCP"] = true,
    ["JTS225-Obrez Monochrome"] = true,
    ["JTS225-Obrez"] = true,
    ["Sawn-off10"] = true,
    ["Nikolai's 'Dented'"] = true,
    ["JS-44"] = true,
    ["BandagePack"] = true,
    ["JTS225-Obrez Poly"] = true,
    ["Mares Leg10"] = true,
    ["RR-LCP10"] = true,
    ["JTS225-Obrez Partycannon"] = true,
    ["Bandages"] = true,
    ["corrodedmetal JS-22"] = true,
    ["CharcoalSteel JS-44"] = true,
    ["SKORPION10"] = true,
    ["Meretta486Palubu Sawn-Off"] = true,
    ["KamatovDRUM"] = true,
    ["Micro KZI"] = true,
    ["Whiteout RR-LightCompactPistolS"] = true,
    ["Clothed SKORPION"] = true,
    ["CharcoalSteel SKORPION"] = true,
    ["Charcoal Steel SKORPION"] = true,
    ["Katya's 'Memories'"] = true,
    ["Dual SKORPS"] = true,
    ["HWISSH-KP9"] = true,
    ["JS2-DerringyGILDED"] = true,
    ["K1911GILDED"] = true,
    ["Mandols-5"] = true,
    ["RDG-2B"] = true,
    ["Testament"] = true,
    ["Jolibri"] = true,
    ["JAVELIN-OBREZS"] = true,
    ["GZhG-7.62"] = true,
    ["AGM22"] = true,
    ["RR-Mark2"] = true,
    ["Dual LCPs"] = true,
    ["RR-LightCompactPistolS10"] = true,
    ["Wild Mandols-5"] = true,
    ["AK47 Case Hardened 1000000"] = true,
    ["Kensington20"] = true,
    ["Kensington"] = true,
    ["ZOZ-106"] = true,
    ["Whizz"] = true,
    ["Rosen Nagan"] = true,
    ["WISP"] = true,
    ["WISP Pearl"] = true,
    ["MAK-1020"] = true,
    ["SKORPION 'AMIRNOV"] = true,
    ["PTRB-41"] = true,
    ["Memorial"] = true,
    ["Mooser"] = true,
    ["VA's ANKM"] = true,
    ["HW-K7"] = true,
    ["TG's JAVELIN-ZVD"] = true,
    ["KR7S"] = true,
    ["RUZKH-12"] = true,
    ["TEKE-9"] = true,
    ["TG's JTS225"] = true,
    ["Mason's Machete"] = true,
    ["Pretty Pink RVK"] = true,
    ["Comically Large Spoon"] = true,
    ["Skeleton Rosen-Obrez"] = true,
    ["Berf-JOLT"] = true,
    ["1895-Rosey"] = true,
    ["K1911 'Memorial'"] = true,
    ["APZ"] = true,
    ["Door'bler"] = true,
    ["JTS225-ObrezGILDED"] = true,
    ["Casaro 91"] = true,
}

local vigilanteWeapons = {
    ["Beagle"] = true,
    ["Beagle TIGERSTRIPES"] = true,
    ["Paradise Beagle"] = true,
    ["IZVEKH-412"] = true,
    ["SilverSteel RR-Snubby"] = true,
    ["RR-Snubby"] = true,
    ["ZKZ-Obrez"] = true,
    ["GG-17"] = true,
    ["J9-M"] = true,
    ["J9-Meretta"] = true,
    ["Pretty Pink GG-17"] = true,
    ["GG-17 TAN"] = true,
    ["GG-17GILDED"] = true,
    ["RR-SnubbyGILDED"] = true,
    ["HWISSH-226"] = true,
    ["ZKZ-Obrez10"] = true,
    ["Buxxberg-COMPACT"] = true,
    ["Pretty Pink Buxxberg-COMPACT"] = true,
    ["JS-5A-Obrez"] = true,
    ["Dual Elites"] = true,
    ["RR-Snubby10"] = true,
    ["DRICO"] = true,
    ["HW-M5K"] = true,
    ["CharcoalSteel I412"] = true,
    ["GG-1720"] = true,
    ["Dual GG-17s"] = true,
    ["Dual GG 17s"] = true,
    ["Mini Ranch Rifle"] = true,
    ["Clothed ZKZ-Obrez"] = true,
    ["Case Hardened DRICO"] = true,
}

local specialKillerWeapons = {
    ["RY's GG-17"] = true,
    ["AT's KAR15"] = true,
    ["VK's ANKM"] = true,
    ["VA's ANKM"] = true,
    ["RVK"] = true,
    ["GZhG-7.62"] = true,
    ["AK47 Case Hardened 1000000"] = true,
    ["TG's JAVELIN-ZVD"] = true,
    ["Mason's Machete"] = true,
    ["Pretty Pink RVK"] = true,
}

local specificJuggernautWeapons = {
    ["AK47 Case Hardened 1000000"] = true,
    ["RVK"] = true,
    ["Pretty Pink RVK"] = true,
}

local allRoleWeapons = {}
for name, _ in pairs(killerWeapons) do allRoleWeapons[name] = true end
for name, _ in pairs(vigilanteWeapons) do allRoleWeapons[name] = true end

-- Role colors and labels
local killerColor = Color3.fromRGB(255, 0, 0)
local killerLabel = "KILLER"
local innocentColor = Color3.fromRGB(0, 255, 0)
local innocentLabel = "INNOCENT"
local vigilanteColor = Color3.fromRGB(0, 255, 255)
local vigilanteLabel = "VIGILANTE"
local hintMatchColor = Color3.new(1, 1, 0)
local hintMatchLabel = "HINT MATCH"
local vigilanteHintColor = Color3.fromRGB(128, 0, 128)
local vigilanteHintLabel = "VIGILANTE + HINT MATCH"
local killerHintColor = Color3.fromRGB(255, 165, 0)
local killerHintLabel = "KILLER + HINT MATCH"

local distanceThreshold = 30

local Players = game:GetService("Players")
local lp = Players.LocalPlayer
local Workspace = game:GetService("Workspace")
local NPCSFolder = Workspace:WaitForChild("NPCSFolder")
local BloodFolder = Workspace:WaitForChild("BloodFolder")

-- Nametag mode variable
local nametagMode = "Role"

-- Function to get character name from NPCSFolder
local function getCharacterName(player)
    if NPCSFolder then
        local playerNPCModel = NPCSFolder:FindFirstChild(player.Name)
        if playerNPCModel then
            local charNameValue = playerNPCModel:FindFirstChild("CharacterName") 
                or playerNPCModel:FindFirstChild("NPCName")
                or playerNPCModel:FindFirstChild("Name")
            
            if charNameValue and charNameValue:IsA("StringValue") then
                return charNameValue.Value
            end
            
            local configObject = playerNPCModel:FindFirstChild("Configuration")
            if configObject then
                local nameInConfig = configObject:FindFirstChild("CharacterName")
                    or configObject:FindFirstChild("NPCName")
                    or configObject:FindFirstChild("Name")
                
                if nameInConfig and nameInConfig:IsA("StringValue") then
                    return nameInConfig.Value
                end
            end
            
            local humanoid = playerNPCModel:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.DisplayName ~= player.Name then
                return humanoid.DisplayName
            end
        end
    end
    return player.Name
end

-- Clear previous overlays
local function clearOldStuff(character)
    if not character then return end

    local oldHighlight = character:FindFirstChild("RoleHighlight")
    if oldHighlight and oldHighlight:IsA("Highlight") then
        oldHighlight:Destroy()
    end

    local head = character:FindFirstChild("Head")
    if head then
        local tag = head:FindFirstChild("RoleBillboard")
        if tag then tag:Destroy() end
    end
end

-- Add floating name tag with customizable text
local function addNameTag(character, text, color, player)
    local head = character:FindFirstChild("Head")
    if not head then return end

    local oldTag = head:FindFirstChild("RoleBillboard")
    if oldTag then oldTag:Destroy() end

    local displayText = text
    if nametagMode == "Username" then
        displayText = player.Name
    elseif nametagMode == "Character Name" then
        displayText = getCharacterName(player)
    end

    local bb = Instance.new("BillboardGui")
    bb.Name = "RoleBillboard"
    bb.Size = UDim2.new(0, 100, 0, 20)
    bb.StudsOffset = Vector3.new(0, 2.5, 0)
    bb.Adornee = head
    bb.AlwaysOnTop = true
    bb.Parent = head

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Text = displayText
    label.TextColor3 = color
    label.TextStrokeTransparency = 0.2
    label.TextScaled = true
    label.Font = Enum.Font.SourceSansBold
    label.Parent = bb
end

-- Tag player by role
local function tagPlayer(player, roleColor, labelText)
    if not player.Character then return end
    clearOldStuff(player.Character)

    local highlight = Instance.new("Highlight", player.Character)
    highlight.Name = "RoleHighlight"
    highlight.Archivable = true
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Enabled = true
    highlight.FillColor = roleColor
    highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
    highlight.FillTransparency = 0.5
    highlight.OutlineTransparency = 0

    if labelText then
        addNameTag(player.Character, labelText, roleColor, player)
    end
end

-- ============================================================================
-- UI CREATION
-- ============================================================================

-- Silent Aimbot Toggle
local AimbotToggle = AimbotTab:CreateToggle({
    Name = "Enable Silent Aimbot",
    CurrentValue = false,
    Flag = "AimbotToggle",
    Callback = function(Value)
        AimbotConfig.Enabled = Value
        if Value then
            if not checkExecutorCompatibility() then
                Rayfield:Notify({
                    Title = "Executor Not Supported",
                    Content = "Your executor is not compatible with this script.",
                    Duration = 5,
                    Image = 4483362458
                })
                AimbotToggle:Set(false)
                return
            end
            initializeAimbot()
            Rayfield:Notify({
                Title = "Silent Aimbot Enabled",
                Content = "Aimbot is now active with current settings.",
                Duration = 3,
                Image = 4483362458
            })
        else
            shutdownAimbot()
            Rayfield:Notify({
                Title = "Silent Aimbot Disabled",
                Content = "Aimbot has been deactivated.",
                Duration = 3,
                Image = 4483362458
            })
        end
    end
})

-- Hit Chance Slider
AimbotTab:CreateSlider({
    Name = "Hit Chance (%)",
    Range = {0, 100},
    Increment = 1,
    Suffix = "%",
    CurrentValue = AimbotConfig.HitChance,
    Flag = "HitChanceSlider",
    Callback = function(Value)
        AimbotConfig.HitChance = Value
    end
})

-- FOV Radius Slider
AimbotTab:CreateSlider({
    Name = "FOV Radius",
    Range = {50, 500},
    Increment = 10,
    Suffix = "px",
    CurrentValue = AimbotConfig.FOVRadius,
    Flag = "FOVRadiusSlider",
    Callback = function(Value)
        AimbotConfig.FOVRadius = Value
    end
})

-- Wall Check Toggle
AimbotTab:CreateToggle({
    Name = "Wall Check",
    CurrentValue = AimbotConfig.WallCheck,
    Flag = "WallCheckToggle",
    Callback = function(Value)
        AimbotConfig.WallCheck = Value
    end
})

-- Show FOV Circle Toggle
AimbotTab:CreateToggle({
    Name = "Show FOV Circle",
    CurrentValue = AimbotConfig.ShowFOVCircle,
    Flag = "ShowFOVCircleToggle",
    Callback = function(Value)
        AimbotConfig.ShowFOVCircle = Value
    end
})

-- Highlight Target Toggle
AimbotTab:CreateToggle({
    Name = "Highlight Target",
    CurrentValue = AimbotConfig.HighlightTarget,
    Flag = "HighlightTargetToggle",
    Callback = function(Value)
        AimbotConfig.HighlightTarget = Value
    end
})

-- Target Parts Dropdown
AimbotTab:CreateDropdown({
    Name = "Target Part",
    Options = {"Head", "Torso", "HumanoidRootPart", "Random"},
    CurrentOption = {"Head"},
    MultipleOptions = false,
    Flag = "TargetPartDropdown",
    Callback = function(Option)
        if Option[1] == "Random" then
            AimbotConfig.UseRandomPart = true
            AimbotConfig.TargetParts = {"Head", "Torso", "HumanoidRootPart"}
        else
            AimbotConfig.UseRandomPart = false
            AimbotConfig.TargetParts = {Option[1]}
        end
    end
})

-- ESP Toggle
local ESPToggle = ESPTab:CreateToggle({
    Name = "Enable ESP",
    CurrentValue = false,
    Flag = "ESPToggle",
    Callback = function(Value)
        espEnabled = Value
        if Value then
            -- ESP initialization code would go here
            Rayfield:Notify({
                Title = "ESP Enabled",
                Content = "Role detection has been turned on.",
                Duration = 3,
                Image = 4483362458
            })
        else
            -- ESP shutdown code would go here
            Rayfield:Notify({
                Title = "ESP Disabled",
                Content = "Role detection has been turned off.",
                Duration = 3,
                Image = 4483362458
            })
        end
    end
})

-- Nametag Mode Dropdown
ESPTab:CreateDropdown({
    Name = "Nametag Display Mode",
    Options = {"Role", "Username", "Character Name"},
    CurrentOption = {"Role"},
    MultipleOptions = false,
    Flag = "NametagModeDropdown",
    Callback = function(Option)
        nametagMode = Option[1] or "Role"
        print("Nametag mode changed to:", nametagMode)
        
        if espEnabled then
            -- Refresh ESP tags
        end
        
        Rayfield:Notify({
            Title = "Nametag Mode Changed",
            Content = "Now displaying: " .. nametagMode,
            Duration = 3,
            Image = 4483362458
        })
    end,
})

-- Teleport to Dropped Gun Button
ESPTab:CreateButton({
    Name = "Teleport to Dropped Gun",
    Callback = function()
        -- Teleport function would go here
        Rayfield:Notify({
            Title = "Feature Not Implemented",
            Content = "Teleport function needs to be added.",
            Duration = 3,
            Image = 4483362458
        })
    end
})

-- Configuration Section
ConfigTab:CreateSection("Aimbot Configuration")

ConfigTab:CreateButton({
    Name = "Reset Aimbot Settings",
    Callback = function()
        AimbotConfig.HitChance = 100
        AimbotConfig.WallCheck = false
        AimbotConfig.FOVRadius = 200
        AimbotConfig.TargetParts = {"Head", "Torso"}
        AimbotConfig.HighlightTarget = true
        AimbotConfig.ShowFOVCircle = true
        AimbotConfig.UseRandomPart = true
        
        -- Update UI elements
        if AimbotToggle then AimbotToggle:Set(false) end
        
        Rayfield:Notify({
            Title = "Settings Reset",
            Content = "Aimbot configuration has been reset to defaults.",
            Duration = 3,
            Image = 4483362458
        })
    end
})

-- Initialize notification
Rayfield:Notify({
    Title = "Script Loaded",
    Content = "ESP & Silent Aimbot are ready to use!",
    Duration = 5,
    Image = 4483362458
})

print("Integrated ESP & Silent Aimbot script loaded successfully")
