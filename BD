--NU-FWQ
--[[
Fully Integrated ESP + Silent Aimbot LocalScript with Rayfield UI
Features: Working Role Detection, Distance Locking, Enhanced Hint Matching, 
CUSTOMIZABLE NAMETAGS, and Silent Aimbot with Full Configuration

COMPLETE: Both ESP and Silent Aimbot run independently with their own toggle buttons
]]

-- Load Rayfield
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

-- Create the window
local Window = Rayfield:CreateWindow({
    Name = "Blood Debt ESP & Silent Aim",
    Icon = 0,
    LoadingTitle = "ESP & Silent Aim",
    LoadingSubtitle = "Integrated Script",
    Theme = "Default",
    DisableRayfieldPrompts = false,
    DisableBuildWarnings = false,
    ConfigurationSaving = {
        Enabled = true,
        FolderName = nil,
        FileName = "BloodDebt_Integrated"
    }
})

-- Create tabs
local ESPTab = Window:CreateTab("ESP", "rewind")
local AimbotTab = Window:CreateTab("Silent Aim", "crosshair")
local ConfigTab = Window:CreateTab("Configuration", "settings")

-- ============================================================================
-- ESP VARIABLES (COMPLETE FROM WORKING SCRIPT)
-- ============================================================================

local espEnabled = false
local stopEspLoop = false
local espPlayerAddedConnection = nil
local espCharacterAddedConnections = {}
local rolesLockedByDistance = false
local lockedDistanceRoles = {}
local playersMatchingHints = {}
local hintTextConnection = nil
local firstVigilanteTracker = {}
local playersWithStandardKillerWeapons = {}
local droppedGunConnections = {}

-- Weapon lists (complete from original)
local killerWeapons = {
    ["CharcoalSteel JS-22"] = true,
    ["Pretty Pink RR-LCP"] = true,
    ["JS2-BondsDerringy"] = true,
    ["GILDED"] = true,
    ["Kamatov"] = true,
    ["JS2-Derringy"] = true,
    ["JS-22"] = true,
    ["RR-LightCompactPistolS"] = true,
    ["J9-Mereta"] = true,
    ["RY's GG-17"] = true,
    ["RR-LCP"] = true,
    ["JS1-Competitor"] = true,
    ["AT's KAR15"] = true,
    ["VK's ANKM"] = true,
    ["Clothed Sawn-off"] = true,
    ["Sawn-off"] = true,
    ["Clothed Rosen-Obrez"] = true,
    ["Rosen-Obrez"] = true,
    ["GraySteel K1911"] = true,
    ["DarkSteel K1911"] = true,
    ["SilverSteel K1911"] = true,
    ["K1911"] = true,
    ["ZZ-90"] = true,
    ["SKORPION"] = true,
    ["Mares Leg"] = true,
    ["RR-LightCompactPistol"] = true,
    ["KamatovS"] = true,
    ["ChromeSlide Turqoise RR-LCP"] = true,
    ["JS1-CYCLOPS"] = true,
    ["THUMPA"] = true,
    ["LUT-E 'KRUS'"] = true,
    ["Memories"] = true,
    ["Hammer n Bullet"] = true,
    ["JS-22GILDED"] = true,
    ["Sawn-offGILDED"] = true,
    ["Door'bler TIGERSTRIPES"] = true,
    ["Anatoly's JS-22"] = true,
    ["PLASTIC JS-22"] = true,
    ["JTS225-OBREZ"] = true,
    ["HEARDBALLA"] = true,
    ["Whiteout Rosen-Obrez"] = true,
    ["Whiteout RR-LCP"] = true,
    ["JTS225-Obrez Monochrome"] = true,
    ["JTS225-Obrez"] = true,
    ["Sawn-off10"] = true,
    ["Nikolai's 'Dented'"] = true,
    ["JS-44"] = true,
    ["BandagePack"] = true,
    ["JTS225-Obrez Poly"] = true,
    ["Mares Leg10"] = true,
    ["RR-LCP10"] = true,
    ["JTS225-Obrez Partycannon"] = true,
    ["Bandages"] = true,
    ["corrodedmetal JS-22"] = true,
    ["CharcoalSteel JS-44"] = true,
    ["SKORPION10"] = true,
    ["Meretta486Palubu Sawn-Off"] = true,
    ["KamatovDRUM"] = true,
    ["Micro KZI"] = true,
    ["Whiteout RR-LightCompactPistolS"] = true,
    ["Clothed SKORPION"] = true,
    ["CharcoalSteel SKORPION"] = true,
    ["Charcoal Steel SKORPION"] = true,
    ["Katya's 'Memories'"] = true,
    ["Dual SKORPS"] = true,
    ["HWISSH-KP9"] = true,
    ["JS2-DerringyGILDED"] = true,
    ["K1911GILDED"] = true,
    ["Mandols-5"] = true,
    ["RDG-2B"] = true,
    ["Testament"] = true,
    ["Jolibri"] = true,
    ["JAVELIN-OBREZS"] = true,
    ["GZhG-7.62"] = true,
    ["AGM22"] = true,
    ["RR-Mark2"] = true,
    ["Dual LCPs"] = true,
    ["RR-LightCompactPistolS10"] = true,
    ["Wild Mandols-5"] = true,
    ["AK47 Case Hardened 1000000"] = true,
    ["Kensington20"] = true,
    ["Kensington"] = true,
    ["ZOZ-106"] = true,
    ["Whizz"] = true,
    ["Rosen Nagan"] = true,
    ["WISP"] = true,
    ["WISP Pearl"] = true,
    ["MAK-1020"] = true,
    ["SKORPION 'AMIRNOV"] = true,
    ["PTRB-41"] = true,
    ["Memorial"] = true,
    ["Mooser"] = true,
    ["VA's ANKM"] = true,
    ["HW-K7"] = true,
    ["TG's JAVELIN-ZVD"] = true,
    ["KR7S"] = true,
    ["RUZKH-12"] = true,
    ["TEKE-9"] = true,
    ["TG's JTS225"] = true,
    ["Mason's Machete"] = true,
    ["Pretty Pink RVK"] = true,
    ["Comically Large Spoon"] = true,
    ["Skeleton Rosen-Obrez"] = true,
    ["Berf-JOLT"] = true,
    ["1895-Rosey"] = true,
    ["K1911 'Memorial'"] = true,
    ["APZ"] = true,
    ["Door'bler"] = true,
    ["JTS225-ObrezGILDED"] = true,
    ["Casaro 91"] = true,
}

local vigilanteWeapons = {
    ["Beagle"] = true,
    ["Beagle TIGERSTRIPES"] = true,
    ["Paradise Beagle"] = true,
    ["IZVEKH-412"] = true,
    ["SilverSteel RR-Snubby"] = true,
    ["RR-Snubby"] = true,
    ["ZKZ-Obrez"] = true,
    ["GG-17"] = true,
    ["J9-M"] = true,
    ["J9-Meretta"] = true,
    ["Pretty Pink GG-17"] = true,
    ["GG-17 TAN"] = true,
    ["GG-17GILDED"] = true,
    ["RR-SnubbyGILDED"] = true,
    ["HWISSH-226"] = true,
    ["ZKZ-Obrez10"] = true,
    ["Buxxberg-COMPACT"] = true,
    ["Pretty Pink Buxxberg-COMPACT"] = true,
    ["JS-5A-Obrez"] = true,
    ["Dual Elites"] = true,
    ["RR-Snubby10"] = true,
    ["DRICO"] = true,
    ["HW-M5K"] = true,
    ["CharcoalSteel I412"] = true,
    ["GG-1720"] = true,
    ["Dual GG-17s"] = true,
    ["Dual GG 17s"] = true,
    ["Mini Ranch Rifle"] = true,
    ["Clothed ZKZ-Obrez"] = true,
    ["Case Hardened DRICO"] = true,
}

local specialKillerWeapons = {
    ["RY's GG-17"] = true,
    ["AT's KAR15"] = true,
    ["VK's ANKM"] = true,
    ["VA's ANKM"] = true,
    ["RVK"] = true,
    ["GZhG-7.62"] = true,
    ["AK47 Case Hardened 1000000"] = true,
    ["TG's JAVELIN-ZVD"] = true,
    ["Mason's Machete"] = true,
    ["Pretty Pink RVK"] = true,
}

local specificJuggernautWeapons = {
    ["AK47 Case Hardened 1000000"] = true,
    ["RVK"] = true,
    ["Pretty Pink RVK"] = true,
}

local allRoleWeapons = {}
for name, _ in pairs(killerWeapons) do allRoleWeapons[name] = true end
for name, _ in pairs(vigilanteWeapons) do allRoleWeapons[name] = true end

-- Role colors and labels
local killerColor = Color3.fromRGB(255, 0, 0)
local killerLabel = "KILLER"
local innocentColor = Color3.fromRGB(0, 255, 0)
local innocentLabel = "INNOCENT"
local vigilanteColor = Color3.fromRGB(0, 255, 255)
local vigilanteLabel = "VIGILANTE"
local hintMatchColor = Color3.new(1, 1, 0)
local hintMatchLabel = "HINT MATCH"
local vigilanteHintColor = Color3.fromRGB(128, 0, 128)
local vigilanteHintLabel = "VIGILANTE + HINT MATCH"
local killerHintColor = Color3.fromRGB(255, 165, 0)
local killerHintLabel = "KILLER + HINT MATCH"

local distanceThreshold = 30

-- Services
local Players = game:GetService("Players")
local lp = Players.LocalPlayer
local Workspace = game:GetService("Workspace")
local NPCSFolder = Workspace:WaitForChild("NPCSFolder")
local BloodFolder = Workspace:WaitForChild("BloodFolder")

-- Nametag mode variable
local nametagMode = "Role"

-- ============================================================================
-- ESP FUNCTIONS (COMPLETE FROM WORKING SCRIPT)
-- ============================================================================

local function getCharacterName(player)
    if NPCSFolder then
        local playerNPCModel = NPCSFolder:FindFirstChild(player.Name)
        if playerNPCModel then
            local charNameValue = playerNPCModel:FindFirstChild("CharacterName") 
                or playerNPCModel:FindFirstChild("NPCName")
                or playerNPCModel:FindFirstChild("Name")
            
            if charNameValue and charNameValue:IsA("StringValue") then
                return charNameValue.Value
            end
            
            local configObject = playerNPCModel:FindFirstChild("Configuration")
            if configObject then
                local nameInConfig = configObject:FindFirstChild("CharacterName")
                    or configObject:FindFirstChild("NPCName")
                    or configObject:FindFirstChild("Name")
                
                if nameInConfig and nameInConfig:IsA("StringValue") then
                    return nameInConfig.Value
                end
            end
            
            local humanoid = playerNPCModel:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.DisplayName ~= player.Name then
                return humanoid.DisplayName
            end
        end
    end
    return player.Name
end

local function clearOldStuff(character)
    if not character then return end

    local oldHighlight = character:FindFirstChild("RoleHighlight")
    if oldHighlight and oldHighlight:IsA("Highlight") then
        oldHighlight:Destroy()
    end

    local head = character:FindFirstChild("Head")
    if head then
        local tag = head:FindFirstChild("RoleBillboard")
        if tag then tag:Destroy() end
    end
end

local function addNameTag(character, text, color, player)
    local head = character:FindFirstChild("Head")
    if not head then return end

    local oldTag = head:FindFirstChild("RoleBillboard")
    if oldTag then oldTag:Destroy() end

    local displayText = text
    if nametagMode == "Username" then
        displayText = player.Name
    elseif nametagMode == "Character Name" then
        displayText = getCharacterName(player)
    end

    local bb = Instance.new("BillboardGui")
    bb.Name = "RoleBillboard"
    bb.Size = UDim2.new(0, 100, 0, 20)
    bb.StudsOffset = Vector3.new(0, 2.5, 0)
    bb.Adornee = head
    bb.AlwaysOnTop = true
    bb.Parent = head

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Text = displayText
    label.TextColor3 = color
    label.TextStrokeTransparency = 0.2
    label.TextScaled = true
    label.Font = Enum.Font.SourceSansBold
    label.Parent = bb
end

local function clearDroppedGunEsp(gunTool)
    if not gunTool then return end
    local old = gunTool:FindFirstChildWhichIsA("Highlight")
    if old then old:Destroy() end
end

local function addDroppedGunEsp(gunTool)
    if not gunTool or not gunTool:IsA("Tool") then return end

    clearDroppedGunEsp(gunTool)

    local highlight = Instance.new("Highlight")
    highlight.Name = "DroppedGunHighlight"
    highlight.Adornee = gunTool
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Enabled = true
    highlight.FillColor = Color3.fromRGB(255, 255, 0)
    highlight.FillTransparency = 0.4
    highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
    highlight.OutlineTransparency = 0
    highlight.Parent = gunTool
end

local function updateDroppedGunEsp()
    if not espEnabled or not BloodFolder then return end

    for _, obj in ipairs(BloodFolder:GetChildren()) do
        if obj:IsA("Tool") then
            local weaponName = obj.Name
            if killerWeapons[weaponName] or vigilanteWeapons[weaponName] or specialKillerWeapons[weaponName] then
                addDroppedGunEsp(obj)

                if not droppedGunConnections[obj] then
                    droppedGunConnections[obj] = obj.AncestryChanged:Connect(function()
                        if not obj.Parent then
                            clearDroppedGunEsp(obj)
                            droppedGunConnections[obj]:Disconnect()
                            droppedGunConnections[obj] = nil
                        end
                    end)
                end
            end
        end
    end
end

local function clearAllDroppedGunEsp()
    if BloodFolder then
        for _, obj in BloodFolder:GetChildren() do
            if obj:IsA("Tool") then
                clearDroppedGunEsp(obj)
            end
        end
    end
    for tool, conn in pairs(droppedGunConnections) do
        if conn and conn.Connected then conn:Disconnect() end
        droppedGunConnections[tool] = nil
    end
end

local function tagPlayer(player, roleColor, labelText)
    if not player.Character then return end
    clearOldStuff(player.Character)

    local highlight = Instance.new("Highlight", player.Character)
    highlight.Name = "RoleHighlight"
    highlight.Archivable = true
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Enabled = true
    highlight.FillColor = roleColor
    highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
    highlight.FillTransparency = 0.5
    highlight.OutlineTransparency = 0

    if labelText then
        addNameTag(player.Character, labelText, roleColor, player)
    end
end

local function collectPlayerTools(player)
    local tools = {}
    local backpack = player:FindFirstChildOfClass("Backpack")
    if backpack then
        for _, tool in ipairs(backpack:GetChildren()) do
            if tool:IsA("Tool") then
                tools[tool.Name] = tool
            end
        end
    end
    if player.Character then
        for _, tool in ipairs(player.Character:GetChildren()) do
            if tool:IsA("Tool") then
                tools[tool.Name] = tool
            end
        end
    end

    if NPCSFolder then
        local playerNPCModel = NPCSFolder:FindFirstChild(player.Name)
        if playerNPCModel then
            for _, child in ipairs(playerNPCModel:GetChildren()) do
                if child:IsA("Tool") then
                    tools[child.Name] = child
                end
            end
        end
    end

    return tools
end

local function getStandardRoleFromWeapons(toolsByName)
    local role = nil
    local color = nil
    local label = nil

    for weaponName, _ in pairs(killerWeapons) do
        if not specialKillerWeapons[weaponName] and toolsByName[weaponName] then
            role = "Killer"
            color = killerColor
            label = killerLabel
            return role, color, label
        end
    end

    for weaponName, _ in pairs(vigilanteWeapons) do
        if toolsByName[weaponName] then
            role = "Vigilante"
            color = vigilanteColor
            label = vigilanteLabel
            return role, color, label
        end
    end

    return nil, nil, nil
end

local function parseSingleHint(hintContent)
    local hintType = "invalid"
    local hintValue = nil
    local cleanedContent = hintContent:match("^%s*(.-)%s*$") or ""

    if string.len(cleanedContent) == 0 then
        return hintType, hintValue
    end

    local taskMatch = cleanedContent:match("^Is often seen%s*(.*)$")
    if taskMatch then
        hintType = "task"
        hintValue = taskMatch:match("^%s*(.-)%s*$")
        return hintType, hintValue
    end

    local traitBracketMatch = cleanedContent:match("^%[.-%]$")
    if traitBracketMatch then
        local cleanClue = traitBracketMatch:gsub("[%[%]]", ""):match("^%s*(.-)%s*$") or ""
        if string.len(cleanClue) > 0 and cleanClue:lower() ~= "assigned task" and cleanClue:lower() ~= "seen" then
            hintType = "trait"
            hintValue = cleanClue
            return hintType, hintValue
        end
    end

    if hintType == "invalid" then
        hintType = "trait"
        hintValue = cleanedContent
    end

    return hintType, hintValue
end

local function updateMatchingHintPlayers()
    playersMatchingHints = {}

    if not espEnabled then return end

    local PlayerGui = Players.LocalPlayer:FindFirstChild("PlayerGui")
    if not PlayerGui then return end

    local TargetHintLabel = PlayerGui:FindFirstChild("RESETONDEATHStatusGui") and PlayerGui.RESETONDEATHStatusGui:FindFirstChild("TARGETHINT")

    if not TargetHintLabel or not TargetHintLabel:IsA("TextLabel") then
        return
    end

    local hintText = TargetHintLabel.Text

    if string.len(string.gsub(hintText, "%s", "")) == 0 then
        return
    end

    local hintPrefix = "Hints : "
    local lowerHintText = string.lower(hintText)
    local lowerHintPrefix = string.lower(hintPrefix)

    if lowerHintText:sub(1, string.len(lowerHintPrefix)) ~= lowerHintPrefix then
        return
    end

    local actualHintContent = hintText:sub(string.len(hintPrefix) + 1):match("^%s*(.-)%s*$")

    local individualHintParts = {}
    local currentPos = 1
    while currentPos <= string.len(actualHintContent) do
        local nextPlus = string.find(actualHintContent, " + ", currentPos, true)
        if nextPlus then
            local hintPart = string.sub(actualHintContent, currentPos, nextPlus - 1)
            table.insert(individualHintParts, hintPart)
            currentPos = nextPlus + string.len(" + ")
        else
            local hintPart = string.sub(actualHintContent, currentPos)
            table.insert(individualHintParts, hintPart)
            currentPos = string.len(actualHintContent) + 1
        end
    end

    if #individualHintParts == 0 and string.len(actualHintContent) > 0 then
        table.insert(individualHintParts, actualHintContent)
    end

    local targetConditions = {}

    for i, hintPartContent in ipairs(individualHintParts) do
        local targetNumberMatch = hintPartContent:match("^%[%s*(%d+)%s*%]")
        local targetNumber = tonumber(targetNumberMatch) or 1
        local cleanedHintPartContent = hintPartContent:gsub("^%[%s*%d+%s*%]%s*", ""):match("^%s*(.-)%s*$") or ""

        local hintType, hintValue = parseSingleHint(cleanedHintPartContent)

        if hintType ~= "invalid" and hintValue and string.len(hintValue) > 0 then
            if not targetConditions[targetNumber] then
                targetConditions[targetNumber] = {}
            end
            table.insert(targetConditions[targetNumber], { type = hintType, value = hintValue })
        end
    end

    if next(targetConditions) == nil then
        return
    end

    if not NPCSFolder then
        return
    end

    for _, player in Players:GetPlayers() do
        if player ~= lp then
            local playerNPCModel = NPCSFolder:FindFirstChild(player.Name)

            if playerNPCModel then
                local configObject = playerNPCModel:FindFirstChild("Configuration")
                local playerMatchesAnyTarget = false

                for targetNumber, conditionsForTarget in pairs(targetConditions) do
                    local playerMatchesAllConditionsForTarget = true

                    for i, condition in ipairs(conditionsForTarget) do
                        local conditionMet = false

                        if condition.type == "task" then
                            local assignedTaskObject = playerNPCModel:FindFirstChild("AssignedTask")
                            if assignedTaskObject and assignedTaskObject:IsA("StringValue") and assignedTaskObject.Value == condition.value then
                                conditionMet = true
                            end
                        elseif condition.type == "trait" then
                            if configObject then
                                for _, configChild in ipairs(configObject:GetChildren()) do
                                    if configChild:IsA("StringValue") then
                                        if configChild.Value == condition.value then
                                            conditionMet = true
                                            break
                                        end
                                    end
                                end
                            end
                        end

                        if not conditionMet then
                            playerMatchesAllConditionsForTarget = false
                            break
                        end
                    end

                    if playerMatchesAllConditionsForTarget then
                        playerMatchesAnyTarget = true
                        break
                    end
                end

                if playerMatchesAnyTarget then
                    playersMatchingHints[player] = true
                end
            end
        end
    end
end

local function connectHintTextSignal()
    if not espEnabled then return end
    if hintTextConnection then
        hintTextConnection:Disconnect()
        hintTextConnection = nil
    end

    local PlayerGui = Players.LocalPlayer:FindFirstChild("PlayerGui")
    if not PlayerGui then return end

    local statusGui = PlayerGui:WaitForChild("RESETONDEATHStatusGui", 20)
    if not statusGui then
        return
    end

    local TargetHintLabel = statusGui:WaitForChild("TARGETHINT", 10)
    if not TargetHintLabel or not TargetHintLabel:IsA("TextLabel") then
        return
    end

    hintTextConnection = TargetHintLabel:GetPropertyChangedSignal("Text"):Connect(updateMatchingHintPlayers)
    updateMatchingHintPlayers()
end

local function detectRoles()
    if not espEnabled then return end

    local everyoneHasGunConditionMet = false
    local noOneHasGunConditionMet = false
    local newHighestPriorityKillerDetected = false
    local theSingleKillerGunHolder = nil
    local specificJuggernautDetected = false
    local theSpecificJuggernautHolder = nil
    local specialKillerDetected = false
    local playersWithSpecialWeapons = {}
    local playersWithValidCharacters = {}
    local playersWithoutAnyGun = {}
    local playersWithAnyGun = {}
    local playersWithVigilanteWeapons = {}
    playersWithStandardKillerWeapons = {}
    local vigilanteCount = 0
    local killerGunHoldersCount = 0
    local singleKillerGunHolderCandidate = nil

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= lp and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            playersWithValidCharacters[player] = true

            local toolsByName = collectPlayerTools(player)
            local hasAnyRoleWeapon = false
            local hasVigilanteWeapon = false
            local hasKillerWeapon = false

            for name, tool in pairs(toolsByName) do
                if specialKillerWeapons[name] then
                    specialKillerDetected = true
                    playersWithSpecialWeapons[player] = true

                    if specificJuggernautWeapons[name] then
                        specificJuggernautDetected = true
                        theSpecificJuggernautHolder = player
                    end
                end
                if allRoleWeapons[name] then
                    hasAnyRoleWeapon = true
                end
                if vigilanteWeapons[name] then
                    hasVigilanteWeapon = true
                    playersWithVigilanteWeapons[player] = true
                end
                if killerWeapons[name] then
                    hasKillerWeapon = true
                    if not specialKillerWeapons[name] then
                        playersWithStandardKillerWeapons[player] = true
                    end
                end
            end

            if hasVigilanteWeapon then
                vigilanteCount = vigilanteCount + 1
                if firstVigilanteTracker[player] == nil then
                    firstVigilanteTracker[player] = true
                end
            end

            if hasKillerWeapon then
                killerGunHoldersCount = killerGunHoldersCount + 1
                singleKillerGunHolderCandidate = player
            end

            if not hasAnyRoleWeapon then
                playersWithoutAnyGun[player] = true
            else
                playersWithAnyGun[player] = true
            end
        else
            clearOldStuff(player.Character)
        end
    end

    if vigilanteCount == 1 and killerGunHoldersCount == 1 and singleKillerGunHolderCandidate then
        newHighestPriorityKillerDetected = true
        theSingleKillerGunHolder = singleKillerGunHolderCandidate
        specialKillerDetected = false
        specificJuggernautDetected = false
        rolesLockedByDistance = false
        lockedDistanceRoles = {}

        if theSingleKillerGunHolder == lp then
            updateMatchingHintPlayers()
        end
    end

    local otherPlayersWithCharCount = 0
    for player, _ in pairs(playersWithValidCharacters) do
        if player ~= lp then otherPlayersWithCharCount = otherPlayersWithCharCount + 1 end
    end

    local allValidTargetsHaveGun = true
    for player, _ in pairs(playersWithValidCharacters) do
        if playersWithoutAnyGun[player] then
            allValidTargetsHaveGun = false
            break
        end
    end
    if allValidTargetsHaveGun and otherPlayersWithCharCount > 0 then
        everyoneHasGunConditionMet = true
    end

    local anyValidTargetHasGun = false
    for player, _ in pairs(playersWithValidCharacters) do
        if playersWithAnyGun[player] then
            anyValidTargetHasGun = true
            break
        end
    end
    if not anyValidTargetHasGun and otherPlayersWithCharCount > 0 then
        noOneHasGunConditionMet = true
    end

    local higherPriorityActive = newHighestPriorityKillerDetected or specificJuggernautDetected or specialKillerDetected

    if not higherPriorityActive then
        if everyoneHasGunConditionMet and not rolesLockedByDistance then
            rolesLockedByDistance = true
            lockedDistanceRoles = {}

            local localHRP = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")

            if localHRP then
                for player, _ in pairs(playersWithValidCharacters) do
                    local playerHRP = player.Character:FindFirstChild("HumanoidRootPart")
                    if playerHRP then
                        local distance = (localHRP.Position - playerHRP.Position).Magnitude
                        if distance >= distanceThreshold then
                            lockedDistanceRoles[player] = "Killer"
                        else
                            lockedDistanceRoles[player] = "Innocent"
                        end
                    end
                end
            else
                rolesLockedByDistance = false
                lockedDistanceRoles = {}
                warn("Blood Debt Role Detector: Distance Lock failed to activate: Local HRP missing.")
            end
        elseif noOneHasGunConditionMet and rolesLockedByDistance then
            rolesLockedByDistance = false
            lockedDistanceRoles = {}
        end
    else
        if rolesLockedByDistance then
            rolesLockedByDistance = false
            lockedDistanceRoles = {}
        end
    end

    updateMatchingHintPlayers()

    for _, player in ipairs(Players:GetPlayers()) do
        if playersWithValidCharacters[player] then
            if newHighestPriorityKillerDetected and player == theSingleKillerGunHolder then
                tagPlayer(player, killerColor, killerLabel)
            elseif specificJuggernautDetected then
                if player == theSpecificJuggernautHolder then
                    tagPlayer(player, killerColor, killerLabel)
                else
                    local toolsByName = collectPlayerTools(player)
                    local hasAnyRoleWeapon = false
                    for name, _ in pairs(toolsByName) do
                        if allRoleWeapons[name] then
                            hasAnyRoleWeapon = true
                            break
                        end
                    end

                    if hasAnyRoleWeapon then
                        tagPlayer(player, vigilanteColor, vigilanteLabel)
                    else
                        tagPlayer(player, innocentColor, innocentLabel)
                    end
                end
            elseif specialKillerDetected then
                if playersWithSpecialWeapons[player] then
                    tagPlayer(player, killerColor, killerLabel)
                else
                    tagPlayer(player, innocentColor, innocentLabel)
                end
            elseif rolesLockedByDistance then
                local lockedRole = lockedDistanceRoles[player]
                if lockedRole then
                    if lockedRole == "Killer" then
                        tagPlayer(player, killerColor, killerLabel)
                    elseif lockedRole == "Innocent" then
                        tagPlayer(player, innocentColor, innocentLabel)
                    end
                else
                    clearOldStuff(player.Character)
                end
            elseif playersMatchingHints[player] and playersWithVigilanteWeapons[player] then
                tagPlayer(player, vigilanteHintColor, vigilanteHintLabel)
            elseif playersMatchingHints[player] and playersWithStandardKillerWeapons[player] then
                tagPlayer(player, killerHintColor, killerHintLabel)
            elseif playersMatchingHints[player] and not playersWithStandardKillerWeapons[player] and not playersWithVigilanteWeapons[player] then
                tagPlayer(player, hintMatchColor, hintMatchLabel)
            else
                local toolsByName = collectPlayerTools(player)
                local standardRole, standardColor, standardLabel = getStandardRoleFromWeapons(toolsByName)
                if standardRole then
                    tagPlayer(player, standardColor, standardLabel)
                else
                    tagPlayer(player, innocentColor, innocentLabel)
                end
            end
        else
            clearOldStuff(player.Character)
        end
    end
end

local function disableEsp()
    if espEnabled then
        espEnabled = false
        stopEspLoop = true
        print("Blood Debt Role Detector: ESP Disabled")

        rolesLockedByDistance = false
        lockedDistanceRoles = {}
        playersMatchingHints = {}
        playersWithStandardKillerWeapons = {}
        firstVigilanteTracker = {}

        if espPlayerAddedConnection then
            espPlayerAddedConnection:Disconnect()
            espPlayerAddedConnection = nil
        end

        if hintTextConnection then
            hintTextConnection:Disconnect()
            hintTextConnection = nil
        end

        for player, connection in pairs(espCharacterAddedConnections) do
            if connection and typeof(connection) == "RBXScriptConnection" then
                connection:Disconnect()
            end
            espCharacterAddedConnections[player] = nil
        end
        espCharacterAddedConnections = {}

        for _, player in ipairs(Players:GetPlayers()) do
            if player.Character then
                clearOldStuff(player.Character)
            end
        end
        clearAllDroppedGunEsp() 
        Rayfield:Notify({
            Title = "ESP Disabled",
            Content = "Role detection and dropped gun ESP have been turned off.",
            Duration = 3,
            Image = 4483362458
        })
    end
end

local function tpToDroppedGun()
    if not BloodFolder then
        warn("Blood Debt Role Detector: BloodFolder not available for teleport.")
        Rayfield:Notify({
            Title = "Error",
            Content = "BloodFolder not found in Workspace.",
            Duration = 5,
            Image = 4483362458
        })
        return
    end

    local foundGun = false
    for _, item in ipairs(BloodFolder:GetChildren()) do
        if item:IsA("Tool") and (killerWeapons[item.Name] or vigilanteWeapons[item.Name] or specialKillerWeapons[item.Name]) then
            local handle = item:FindFirstChild("Handle")

            if handle and handle:IsA("BasePart") then
                local targetPosition = handle.Position + Vector3.new(0, 5, 0)

                if lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
                    lp.Character:SetPrimaryPartCFrame(CFrame.new(targetPosition))
                    foundGun = true
                    break
                else
                    warn("Blood Debt Role Detector: Local player character or HRP not found for teleport.")
                    Rayfield:Notify({
                        Title = "Error",
                        Content = "Cannot teleport: Your character is not ready.",
                        Duration = 5,
                        Image = 4483362458
                    })
                    return
                end
            else
                warn("Tool '"..item.Name.."' found in BloodFolder but missing a valid Handle part for teleportation.")
            end
        end
    end

    if not foundGun then
        Rayfield:Notify({
            Title = "No Gun Found",
            Content = "There are no valid guns in the BloodFolder.",
            Duration = 5,
            Image = 4483362458
        })
    end
end

-- ============================================================================
// SILENT AIMBOT CONFIGURATION
-- ============================================================================

local AimbotConfig = {
    HitChance = 100,
    WallCheck = false,
    TargetParts = {"Head", "Torso"},
    FOVRadius = 200,
    MaxIndicators = 2,
    IndicatorLifetime = 0.05,
    IndicatorSize = 0.5,
    CircleThickness = 2,
    CircleSides = 60,
    HighlightTarget = true,
    HighlightColor = Color3.new(1, 0, 0),
    HighlightTransparency = 0.5,
    Enabled = false,
    ShowFOVCircle = true,
    UseRandomPart = true
}

-- ============================================================================
// AIMBOT VARIABLES AND FUNCTIONS
-- ============================================================================

local aimbotActive = false
local aimbotThread = nil
local hitIndicators = {}
local currentHighlight = nil
local aimbotConnections = {}
local originalFire = nil
local FastCast = nil
local Camera = nil
local LocalPlayer = nil
local RunService = nil
local Workspace = nil
local ReplicatedStorage = nil

-- Apply global config if exists
if getgenv().HitChance then AimbotConfig.HitChance = getgenv().HitChance end
if getgenv().wallcheck ~= nil then AimbotConfig.WallCheck = getgenv().wallcheck end
if getgenv().TargetParts then AimbotConfig.TargetParts = getgenv().TargetParts end
if getgenv().radius then AimbotConfig.FOVRadius = getgenv().radius end
if getgenv().HighlightTarget ~= nil then AimbotConfig.HighlightTarget = getgenv().HighlightTarget end

-- Executor compatibility check
local function checkExecutorCompatibility()
    local success, executorName, version = pcall(identifyexecutor)
    if not success then return true end
    
    executorName = (executorName and executorName:upper()) or ""
    local blocked = {"XENO", "SOLARA"}
    
    for _, name in ipairs(blocked) do
        if executorName:find(name) then
            game.Players.LocalPlayer:Kick("Unsupported executor. Please use an alternative.")
            return false
        end
    end
    return true
end

-- Get executor global
local function getExecutorGlobal(...)
    for _, name in ipairs({...}) do
        local value = rawget(_G, name)
        if value then return value end
    end
    return nil
end

-- Check FFlag
local function checkFFlag(name, expectedValue)
    local success, result = pcall(getfflag, name)
    if not success then return false end
    
    if type(expectedValue) == "boolean" then
        return result == expectedValue
    end
    return tostring(result) == tostring(expectedValue)
end

-- Bin cleanup system
local Bin = {}
Bin.__index = Bin

function Bin.new()
    return setmetatable({head = nil, tail = nil}, Bin)
end

function Bin:add(item)
    local node = {item = item, next = nil}
    if not self.head then self.head = node end
    if self.tail then self.tail.next = node end
    self.tail = node
    return item
end

function Bin:batch(...)
    for _, item in ipairs({...}) do self:add(item) end
end

function Bin:destroy()
    while self.head do
        local item = self.head.item
        if type(item) == "function" then
            item()
        elseif typeof(item) == "RBXScriptConnection" then
            item:Disconnect()
        elseif type(item) == "thread" then
            task.cancel(item)
        elseif type(item) == "table" and (item.destroy or item.Destroy) then
            (item.destroy or item.Destroy)(item)
        end
        self.head = self.head.next
    end
    self.tail = nil
end

-- Base Component
local BaseComponent = {}
BaseComponent.__index = BaseComponent

function BaseComponent.new(instance)
    local self = setmetatable({}, BaseComponent)
    self.instance = instance
    self.bin = Bin.new()
    return self
end

function BaseComponent:destroy()
    self.bin:destroy()
end

-- Rig Component
local RigComponent = setmetatable({}, {__index = BaseComponent})
RigComponent.__index = RigComponent

function RigComponent.new(instance)
    local self = setmetatable(BaseComponent.new(instance), RigComponent)
    
    self.root = instance:WaitForChild("HumanoidRootPart", 5)
    self.head = instance:WaitForChild("Head", 5)
    self.humanoid = instance:WaitForChild("Humanoid", 5)
    
    if not (self.root and self.head and self.humanoid) then
        error("Failed to initialize rig components")
    end
    
    self.bin:batch(
        self.humanoid.Died:Connect(function() self:destroy() end),
        instance.Destroying:Connect(function() self:destroy() end)
    )
    
    return self
end

-- Character Component
local CharacterComponent = setmetatable({}, {__index = RigComponent})
CharacterComponent.__index = CharacterComponent
CharacterComponent.active = {}

function CharacterComponent.new(instance)
    return setmetatable(RigComponent.new(instance), CharacterComponent)
end

-- Player Component
local PlayerComponent = setmetatable({}, {__index = BaseComponent})
PlayerComponent.__index = PlayerComponent
PlayerComponent.active = {}

function PlayerComponent.new(instance)
    local self = setmetatable(BaseComponent.new(instance), PlayerComponent)
    self.name = instance.Name
    self.character = nil
    
    if instance.Character then
        task.spawn(function() self:onCharacterAdded(instance.Character) end)
    end
    
    self.bin:batch(
        instance.CharacterAdded:Connect(function(char) self:onCharacterAdded(char) end),
        instance.CharacterRemoving:Connect(function() self:onCharacterRemoving() end)
    )
    
    self.bin:add(function()
        PlayerComponent.active[instance] = nil
    end)
    
    PlayerComponent.active[instance] = self
    return self
end

function PlayerComponent:onCharacterAdded(character)
    if self.character then self.character:destroy() end
    self.character = CharacterComponent.new(character)
end

function PlayerComponent:onCharacterRemoving()
    if self.character then self.character:destroy() end
    self.character = nil
end

-- Component Controller
local ComponentController = {}
local rayParams

local function getRandomPart(character)
    local parts = {}
    for _, partName in ipairs(AimbotConfig.TargetParts) do
        local part = character.instance:FindFirstChild(partName)
        if part then table.insert(parts, part) end
    end
    
    if #parts == 0 then return nil end
    return parts[Random.new():NextInteger(1, #parts)]
end

function ComponentController.getTarget()
    local viewportSize = Camera.ViewportSize
    local screenCenter = Vector2.new(viewportSize.X / 2, viewportSize.Y / 2)
    local bestTarget, bestPart, bestWeight = nil, nil, -math.huge
    
    for _, component in pairs(PlayerComponent.active) do
        local character = component.character
        if not character then continue end
        
        local targetPart = AimbotConfig.UseRandomPart and getRandomPart(character) or character.instance:FindFirstChild(AimbotConfig.TargetParts[1])
        if not targetPart then continue end
        
        local position = character.root.Position
        local viewportPoint = Camera:WorldToViewportPoint(position)
        if viewportPoint.Z < 0 then continue end
        
        if AimbotConfig.WallCheck then
            local origin = Camera.CFrame.Position
            rayParams.FilterDescendantsInstances = {character.instance, LocalPlayer.Character}
            if Workspace:Raycast(origin, position - origin, rayParams) then
                continue
            end
        end
        
        local screenDistance = (Vector2.new(viewportPoint.X, viewportPoint.Y) - screenCenter).Magnitude
        if screenDistance > AimbotConfig.FOVRadius then continue end
        
        local weight = 1000 - screenDistance
        if weight > bestWeight then
            bestTarget = character
            bestPart = targetPart
            bestWeight = weight
        end
    end
    
    return bestTarget, bestPart
end

function ComponentController.init()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            task.spawn(function() PlayerComponent.new(player) end)
        end
    end
    
    Players.PlayerAdded:Connect(function(player)
        PlayerComponent.new(player)
    end)
    
    Players.PlayerRemoving:Connect(function(player)
        local component = PlayerComponent.active[player]
        if component then component:destroy() end
    end)
    
    rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Exclude
    rayParams.IgnoreWater = true
end

-- Range Controller with Hit Indicators
local RangeController = {}

local function calculateChance(percentage)
    percentage = math.floor(percentage)
    local chance = Random.new():NextNumber(0, 100)
    return chance <= percentage
end

local function showHitIndicator(position)
    local part = Instance.new("Part")
    part.Anchored = true
    part.CanCollide = false
    part.Size = Vector3.new(0.5, 0.5, 0.5)
    part.Shape = Enum.PartType.Ball
    part.Color = Color3.new(1, 0, 0)
    part.Material = Enum.Material.Neon
    part.Transparency = 0
    part.Position = position
    part.Parent = Workspace
    
    if #hitIndicators >= AimbotConfig.MaxIndicators then
        local oldest = table.remove(hitIndicators, 1)
        if oldest and oldest.Parent then oldest:Destroy() end
    end
    table.insert(hitIndicators, part)
    
    task.spawn(function()
        task.wait(AimbotConfig.IndicatorLifetime)
        if part and part.Parent then part:Destroy() end
        for i, indicator in ipairs(hitIndicators) do
            if indicator == part then
                table.remove(hitIndicators, i)
                break
            end
        end
    end)
end

local function updateTargetHighlight(character)
    if not AimbotConfig.HighlightTarget then
        if currentHighlight then
            currentHighlight:Destroy()
            currentHighlight = nil
        end
        return
    end
    
    if character then
        if not currentHighlight or currentHighlight.Adornee ~= character.instance then
            if currentHighlight then
                currentHighlight:Destroy()
            end
            
            currentHighlight = Instance.new("Highlight")
            currentHighlight.Adornee = character.instance
            currentHighlight.FillColor = AimbotConfig.HighlightColor
            currentHighlight.OutlineColor = Color3.new(1, 1, 1)
            currentHighlight.FillTransparency = AimbotConfig.HighlightTransparency
            currentHighlight.OutlineTransparency = 0
            currentHighlight.Parent = character.instance
        end
    else
        if currentHighlight then
            currentHighlight:Destroy()
            currentHighlight = nil
        end
    end
end

function RangeController.init()
    if not FastCast or originalFire then return end
    
    originalFire = FastCast.Fire
    
    FastCast.Fire = function(...)
        if not aimbotActive or not AimbotConfig.Enabled then
            return originalFire(...)
        end
        
        local args = {...}
        local bestCharacter, bestPart = ComponentController.getTarget()
        
        updateTargetHighlight(bestCharacter)
        
        if bestCharacter and bestPart and calculateChance(AimbotConfig.HitChance) then
            local targetPos = bestPart.Position
            local origin = args[2]
            local newDirection = (targetPos - origin).Unit * 1000
            args[3] = newDirection
            
            showHitIndicator(targetPos)
        end
        
        return originalFire(unpack(args))
    end
end

-- Visuals Controller
local VisualsController = {}
local fovCircle = nil

function VisualsController.init()
    if fovCircle then return end
    
    fovCircle = Drawing.new("Circle")
    fovCircle.Filled = false
    fovCircle.NumSides = AimbotConfig.CircleSides
    fovCircle.Thickness = AimbotConfig.CircleThickness
    fovCircle.Visible = false
    fovCircle.Color = Color3.new(1, 1, 1)
    fovCircle.Transparency = 1
    
    RunService.RenderStepped:Connect(function()
        if fovCircle and AimbotConfig.ShowFOVCircle and AimbotConfig.Enabled then
            local viewportSize = Camera.ViewportSize
            local screenCenter = Vector2.new(viewportSize.X / 2, viewportSize.Y / 2)
            fovCircle.Radius = AimbotConfig.FOVRadius
            fovCircle.Position = screenCenter
            fovCircle.Visible = true
        elseif fovCircle then
            fovCircle.Visible = false
        end
    end)
end

-- Camera Controller
local CameraController = {}

function CameraController.init()
    Camera = Workspace.CurrentCamera
    Workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
        Camera = Workspace.CurrentCamera or Camera
    end)
end

-- Initialize aimbot systems
local function initializeAimbot()
    if aimbotActive then return end
    
    -- Services
    Players = game:GetService("Players")
    RunService = game:GetService("RunService")
    ReplicatedStorage = game:GetService("ReplicatedStorage")
    Workspace = game:GetService("Workspace")
    LocalPlayer = Players.LocalPlayer
    
    -- Game-specific modules
    local Gun_utls = ReplicatedStorage:WaitForChild("gun_res", 30)
    local gun_lib = Gun_utls:WaitForChild("lib", 30)
    local projectileHandlerMod = gun_lib:WaitForChild("projectileHandler", 30)
    FastCast = require(projectileHandlerMod:WaitForChild("FastCastRedux", 30))
    Camera = Workspace.CurrentCamera
    
    ComponentController.init()
    RangeController.init()
    VisualsController.init()
    CameraController.init()
    
    aimbotActive = true
    print("Silent Aimbot initialized successfully")
end

-- Shutdown aimbot
local function shutdownAimbot()
    if not aimbotActive then return end
    
    -- Restore original Fire function
    if FastCast and originalFire then
        FastCast.Fire = originalFire
    end
    
    -- Clear highlights
    if currentHighlight then
        currentHighlight:Destroy()
        currentHighlight = nil
    end
    
    -- Clear hit indicators
    for _, indicator in ipairs(hitIndicators) do
        if indicator and indicator.Parent then
            indicator:Destroy()
        end
    end
    hitIndicators = {}
    
    -- Clear FOV circle
    if fovCircle then
        fovCircle:Remove()
        fovCircle = nil
    end
    
    -- Clear component data
    for _, component in pairs(PlayerComponent.active) do
        component:destroy()
    end
    PlayerComponent.active = {}
    
    aimbotActive = false
    print("Silent Aimbot shutdown complete")
end

-- ============================================================================
// UI CREATION
-- ============================================================================

-- Silent Aimbot Toggle
local AimbotToggle = AimbotTab:CreateToggle({
    Name = "Enable Silent Aimbot",
    CurrentValue = false,
    Flag = "AimbotToggle",
    Callback = function(Value)
        AimbotConfig.Enabled = Value
        if Value then
            if not checkExecutorCompatibility() then
                Rayfield:Notify({
                    Title = "Executor Not Supported",
                    Content = "Your executor is not compatible with this script.",
                    Duration = 5,
                    Image = 4483362458
                })
                AimbotToggle:Set(false)
                return
            end
            initializeAimbot()
            Rayfield:Notify({
                Title = "Silent Aimbot Enabled",
                Content = "Aimbot is now active with current settings.",
                Duration = 3,
                Image = 4483362458
            })
        else
            shutdownAimbot()
            Rayfield:Notify({
                Title = "Silent Aimbot Disabled",
                Content = "Aimbot has been deactivated.",
                Duration = 3,
                Image = 4483362458
            })
        end
    end
})

-- Hit Chance Slider
AimbotTab:CreateSlider({
    Name = "Hit Chance (%)",
    Range = {0, 100},
    Increment = 1,
    Suffix = "%",
    CurrentValue = AimbotConfig.HitChance,
    Flag = "HitChanceSlider",
    Callback = function(Value)
        AimbotConfig.HitChance = Value
    end
})

-- FOV Radius Slider
AimbotTab:CreateSlider({
    Name = "FOV Radius",
    Range = {50, 500},
    Increment = 10,
    Suffix = "px",
    CurrentValue = AimbotConfig.FOVRadius,
    Flag = "FOVRadiusSlider",
    Callback = function(Value)
        AimbotConfig.FOVRadius = Value
    end
})

-- Wall Check Toggle
AimbotTab:CreateToggle({
    Name = "Wall Check",
    CurrentValue = AimbotConfig.WallCheck,
    Flag = "WallCheckToggle",
    Callback = function(Value)
        AimbotConfig.WallCheck = Value
    end
})

-- Show FOV Circle Toggle
AimbotTab:CreateToggle({
    Name = "Show FOV Circle",
    CurrentValue = AimbotConfig.ShowFOVCircle,
    Flag = "ShowFOVCircleToggle",
    Callback = function(Value)
        AimbotConfig.ShowFOVCircle = Value
    end
})

-- Highlight Target Toggle
AimbotTab:CreateToggle({
    Name = "Highlight Target",
    CurrentValue = AimbotConfig.HighlightTarget,
    Flag = "HighlightTargetToggle",
    Callback = function(Value)
        AimbotConfig.HighlightTarget = Value
    end
})

-- Target Parts Dropdown
AimbotTab:CreateDropdown({
    Name = "Target Part",
    Options = {"Head", "Torso", "HumanoidRootPart", "Random"},
    CurrentOption = {"Head"},
    MultipleOptions = false,
    Flag = "TargetPartDropdown",
    Callback = function(Option)
        if Option[1] == "Random" then
            AimbotConfig.UseRandomPart = true
            AimbotConfig.TargetParts = {"Head", "Torso", "HumanoidRootPart"}
        else
            AimbotConfig.UseRandomPart = false
            AimbotConfig.TargetParts = {Option[1]}
        end
    end
})

-- ESP Toggle - COMPLETE WITH ALL FUNCTIONALITY
local ESPToggle = ESPTab:CreateToggle({
    Name = "Enable ESP",
    CurrentValue = false,
    Flag = "ESPToggle",
    Callback = function(Value)
        espEnabled = Value
        if Value then
            espEnabled = true
            stopEspLoop = false
            print("Blood Debt Role Detector: ESP Enabled")

            -- Start ESP detection loop
            task.spawn(function()
                while espEnabled and not stopEspLoop do
                    task.wait(0.5)
                    updateDroppedGunEsp()
                    detectRoles()
                end
                print("Blood Debt Role Detector: ESP Detection loop stopped.")
            end)

            -- Connect player events
            espPlayerAddedConnection = game.Players.PlayerAdded:Connect(function(player)
                local charAddedConn = player.CharacterAdded:Connect(function(character)
                    task.wait(0.1)
                    connectHintTextSignal()
                    detectRoles()
                end)
                espCharacterAddedConnections[player] = charAddedConn

                if player.Character then
                    task.wait(0.1)
                    detectRoles()
                end
            end)

            -- Handle player removing
            game.Players.PlayerRemoving:Connect(function(player)
                if espCharacterAddedConnections[player] then
                    if typeof(espCharacterAddedConnections[player]) == "RBXScriptConnection" then
                        espCharacterAddedConnections[player]:Disconnect()
                    end
                    espCharacterAddedConnections[player] = nil
                end
                clearOldStuff(player.Character)
            end)

            -- Connect hint text signal
            connectHintTextSignal()
            
            -- Initial detection
            detectRoles()
            updateDroppedGunEsp()

            Rayfield:Notify({
                Title = "ESP Enabled",
                Content = "Role detection has been turned on.",
                Duration = 3,
                Image = 4483362458
            })
        else
            disableEsp()
        end
    end
})

-- Nametag Mode Dropdown
ESPTab:CreateDropdown({
    Name = "Nametag Display Mode",
    Options = {"Role", "Username", "Character Name"},
    CurrentOption = {"Role"},
    MultipleOptions = false,
    Flag = "NametagModeDropdown",
    Callback = function(Option)
        nametagMode = Option[1] or "Role"
        print("Blood Debt Role Detector: Nametag mode changed to:", nametagMode)
        
        -- Re-apply tags to update nametags immediately
        if espEnabled then
            detectRoles()
        end
        
        Rayfield:Notify({
            Title = "Nametag Mode Changed",
            Content = "Now displaying: " .. nametagMode,
            Duration = 3,
            Image = 4483362458
        })
    end,
})

-- Teleport to Dropped Gun Button
ESPTab:CreateButton({
    Name = "Teleport to Dropped Gun",
    Callback = function()
        tpToDroppedGun()
    end
})

-- Configuration Section
ConfigTab:CreateSection("Aimbot Configuration")

ConfigTab:CreateButton({
    Name = "Reset Aimbot Settings",
    Callback = function()
        AimbotConfig.HitChance = 100
        AimbotConfig.WallCheck = false
        AimbotConfig.FOVRadius = 200
        AimbotConfig.TargetParts = {"Head", "Torso"}
        AimbotConfig.HighlightTarget = true
        AimbotConfig.ShowFOVCircle = true
        AimbotConfig.UseRandomPart = true
        
        Rayfield:Notify({
            Title = "Settings Reset",
            Content = "Aimbot configuration has been reset to defaults.",
            Duration = 3,
            Image = 4483362458
        })
    end
})

-- Initialize notification
Rayfield:Notify({
    Title = "Script Loaded",
    Content = "ESP & Silent Aimbot are ready to use!",
    Duration = 5,
    Image = 4483362458
})

print("Fully Integrated ESP & Silent Aimbot script loaded successfully")
